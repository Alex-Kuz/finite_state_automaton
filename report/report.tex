\documentclass[12pt]{article}
\usepackage{ucs}
\usepackage[cp1251]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath}
\usepackage{ulem}           
\usepackage[noend]{algorithmic}                            
\usepackage{lipsum}% Мало ли пригодится рыба
\usepackage{titletoc}% http://ctan.org/pkg/titletoc
\usepackage[usenames,dvipsnames]{color}
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    %backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\renewcommand*\contentsname{Оглавление}
\titlecontents*{chapter}% <section-type>
  [0pt]% <left>
  {}% <above-code>
  {\bfseries\chaptername\ \thecontentslabel\quad}% <numbered-entry-format>
  {}% <numberless-entry-format>
  {\bfseries\hfill\contentspage}% <filler-page-format>


\title{Детерминизация конечного автомата}

\date{}
\author{Кузнецов А.Д.}

\begin{document}
	\maketitle	
	\pagenumbering{arabic}
	\tableofcontents

	\section{Краткая теоретическая часть}
		Ниже приводятся определения и утверждения, которые будут использованы для дальнейших пояснений к реализации алгоритма детерминизации.
		\subsection{Автомат}
		Конечный недетерминированный автомат (КНА) $M$ --- это кортеж вида
		\[
			M = ( A, Q, q_0, F, \delta),	
		\]
		где	
		\begin{itemize}
			\item $A =  \{a_0, a_1, \dots, a_{m-1}\}$ --- входной алфавит, т.е. множество символов, причем конечное : $ |A| = m $;
			\item $Q =  \{q_0, q_1, \dots, q_{n-1}\}$ --- множество состояний автомата,\\ тоже конечное: $|Q|=n$;
			\item $q_0$ --- начальное состояние автомата, то есть $q_0 \in Q$;
			\item $F \subset Q$ --- выходные состояния автомата; 
			\item $\delta: Q\times A\rightarrow 2^Q$ --- функция переходов автомата.
		\end{itemize}
		Если в автомате разрешены переходы по пустому символу, то входной алфавит дополняется фиктивным символом $\lambda$ (в иностранной литературе его чаще обозначают $\varepsilon$). В таком случае автомат называют $\lambda$-КНА ($\varepsilon$-FSA). Входной алфавит при этом будем обозначать так же, то есть если речь идет о $\lambda$-КНА, то подразумевается, что $A~\leftarrow~A~\bigcup~\{\lambda\}$, а мощность $|A|=m + 1$.
		
		Конечный детерминированный автомат (КДА) $M$ --- это такой КНА, где функция переходов $\delta$ выглядит так:
		\[
			\delta: Q\times A\rightarrow 2^Q,	
		\]
		т.е. из любого состояния по любой букве возможен переход в точности в одно состояние - это и обеспечивает детерминированность работы такого автомата.
		\subsection{Теорема Клини}
		Пусть $A=\{a_0,...,a_{n-1}\}$ - произвольный алфавит. Язык $L\subseteq A^*$ является элементом полукольца регулярных языков $R(A)$ в алфавите $A$ тогда и только тогда, когда он допускается некоторым конечным автоматом.
		



	\section{Постановка задачи}
	Теперь сформулируем задачу в вышеуказанных терминах:
	\begin{center}
  		Реализовать алгоритм преобразования $\lambda$-КНА $M$ в КНА $\hat M$ так, чтобы распознаваемые ими языки совпадали, т.е. $L(M)=L(\hat M)$.
	\end{center}
	
	\section{Алгоритм детерминизации автомата}
		Алгоритм детерминизации осуществляется в два шага - удаление $\lambda$-переходов (то есть переход от $\lambda$-КНА к КНА) и непосредственно детерминизация КНА (КНА $\rightarrow$ КДА).
		\subsection{Удаление $\lambda$-переходов}
		Для любого $\lambda$-КНА можно построить эквивалентный ему КНА (Здесь и далее под эквивалентностью автоматов подразумевается совпадение распознаваемых ими языков). Доказательство этого утверждения входит в обоснование алгоритма детерминизации, который описан в учебникех~\cite{Discra}. 
		Основная идея этого шага такая - из состояния $q_i$ существует переход по букве $a$ в состояние $q_j$ тогда и только тогда, когда выполняется одно из двух условий:
		\begin{itemize}
			\item $q_j \in \delta(q_i, a)$;
			\item $\exists (q_{1}, q_{2},\dots, q_{p}) \in \bigcup \limits_{p=1}^{n}Q^p : \\ (q_1 \in \delta(q_i, \lambda))\wedge (\forall k = \overline{1,p-1})(q_k \in \delta(q_{k+1}, \lambda))\wedge(q_p in \delta(q_i, a)) $.
		\end{itemize}
		То есть, если из состояния $q_i$ какая-то цепь пустых переходов ведет в состояние, из которого есть переход в $q_i$ по букве $a$, то в новом КНА будет переход из $q_i$ в $q_i$ по букве $a$.
		\subsection{Детерминизация КНА}
		Теперь у нас есть КНА, который всегда можно детерминизировать (это утверждение тоже есть и доказано в учебнике).
		
		Алгоритм интуитивно следует понимать так: если моделировать КНА на компьютере, то прежде всего придется реализовать автомат так, чтобы он мог находиться одновременно в различных состояниях, в которые он может попасть по прочитанному подслову входной последовательности. Точно так же и тут - пусть в КДА состояния будут в биективном отношении с совокупностью подмножеств состояний входного КДА. Такие состояния результирующего КДА будем называть гиперсостоянием (исключительно ради удобства, в коде, реализующем алгоритм, они так и называются). Помимо этого, будем говорить, что состояние входит в гиперсостояние. если это состояние входит в то подмножество $Q$, в котором гиперсостояние находится в биективном отношении.
		
		Теперь вполне разумна мысль. что переход из одного гиперсостояния в другое по букве возможен тогда, когда хотя бы из одного состояния в первом гиперсостоянии есть переход по этой букве в состояния из второго гиперсостояния. Вообще и обратное следствие верно, но доказывать его сложнее.
		
		В результирующем автомате гиперсостояния связаны со множеством $2^Q$ инъективным отношением, поэтому в новом КДА необходимо определить функцию переходов следующим образом:
		\[
			\hat\delta: S \times A \rightarrow S,  
				\text{ где} \ \ \exists \xi: S \rightarrow 2^Q - \text{инъекция}.
		\]	
		
		Так как уже невозможно это произносить, читать и, поверьте мне, печатать, перейдем непосредственно к алгоритму.
		
		
		\newpage
		
		\def\algorithmicrequire{\textbf{Вход:}}
		\def\algorithmicensure{\textbf{Выход:}}
		\def\algorithmicif{\textbf{если}}
		\def\algorithmicthen{\textbf{то}}
		\def\algorithmicelse{\textbf{иначе}}
		\def\algorithmicelsif{\textbf{иначе если}}
		\def\algorithmicfor{\textbf{для}}
		\def\algorithmicforall{\textbf{для всех}}
		\def\algorithmicdo{}
		\def\algorithmicwhile{\textbf{пока}}
		\def\algorithmicrepeat{\textbf{повторять}}
		\def\algorithmicuntil{\textbf{пока}}
		\def\algorithmicloop{\textbf{цикл}}
		% переопределение стиля комментариев
		\def\algorithmiccomment#1{\quad// {\sl #1}}
		
		
		\begin{algorithmic}[1]
			\REQUIRE $M = ( A, Q, q_0, F, \delta)$;
			\ENSURE $\hat M = (\hat A, S, s_0, F_s, \hat\delta)$;
			\STATE $\hat A := A$; \COMMENT{Алфавиты совпадают}
			\STATE $ s_0 := \{q_0\}$ \COMMENT{Входное гиперсостояние соответсвует входному состоянию исходного автомата}
			\STATE $ F_s = \O $ \COMMENT{Множество выходных гиперсостояний}
			\STATE $ DET = \O $ \COMMENT{Множество уже детерминизированных гиперсостояний}
			\STATE $ NONDET =  \{s_0\}$ \COMMENT{Множество еще недетерминизированных гиперсостояний}
			
			\WHILE{$NONDET \neq \O$} 				
				\STATE $ state := choice(NONDET)$; \COMMENT{Выбираем како-либо элемент из множества и извлекаем его}
				\FORALL{$a \in A$}
					\STATE $ next := \O$; \COMMENT{Новое гиперсостояние при переходе по букве $a$}
					\FORALL{$q \in state$}
						\STATE $ next := next\ \cup\ \delta(q,a) $; 
					\ENDFOR
					\STATE $\hat\delta(state, a) := next $;\COMMENT{Добавляем соответствующий переход по букве}
					\IF{$next \notin DET$}
						\STATE $ NONDET := NONDET \ \cup\ \{next\}$; \COMMENT{Если гиперсостояние не было детерминированно, то добавляем его в множество ожидающих детерминизацию}
					\ENDIF
					\IF{$state \cap F \neq \O$}
						\STATE $ F_s := F_s \ \cup\ \{state\}$; \COMMENT{Если хотя бы одно состояние гиперсостояния было выходным, то все гиперсостояние - выходное}
					\ENDIF
				\ENDFOR
			\ENDWHILE
			\STATE $ S := DET $ ;
			\STATE $ \hat M = (\hat A, S, s_0, F_s, \hat\delta)$ ; \COMMENT{Возвращаем детерминированный автомат}
			
		\end{algorithmic}
	
		\subsection{Оценка сложности алгоритма}
		Очевидно, самая сложная часть этого алгоритма - детерминизация КНА. Количество гиперсостояний органиченно сверху числом $2^n$, так как различных гиперсостояний ровно столько, сколько различных подмножеств $n$-элементного множетсва состояний $Q$. То есть в худшем случае предстоит детерминизировать $O(2^n)$ гиперсостояний.
		
		 При каждой детерминизации гиперсостояния алгоритм проверяет по всем буквам (8 строка алгоритма) и по всем состояниям, которые оно в себе содержит, переходы, а затем объекдиняет их с уже выявленными для предыдущих букв, то есть сложность такого шага $O(m)O(n)O(n) = O(mn^2)$ (это явно сложнее чем еще одно пересечение (15 строка) и объединение (16 строка), так что это и будет сложность шага.
		 
		 Итого $O(2^n)$ шагов сложностью $O(mn^2)$, итого  $O(mn^22^n)$.
		 
	\section{Реализация алгоритма детерминизации автомата}
		Ниже указаны лишь те моменты реализации автоматов и алгоритмов на языке c++ (стандарт с++17), которые действительно заслуживают внимания.
		\subsection{Кодирование автоматов (реализация классов)}
		Итак, автомат - это кортеж некоторых математических объектов, 2 из которых - конечные множества, 1 - подмножество одного из ранее указанных множеств, 1 - элемент множества и какая-то функция, множеством значений которой есть булеан конечного множества. Ясно, что придется кодировать множеста и подмножества. Ситуация осложняется тем, что вообще, и множеством входных символов, и множеством состояний могут быть что угодно. Даже думать не надо, чтобы построить автомат, алфавит которого - разные виды верблюдов, автомат бы распознавал регулярные каравны, а множеством состояний этого автомата могут быть и другие автоматы. Маразм, одним словом, но математика этого делать не запрещает. Однако, на алгоритме детерминизации это абсолютно никак не скажется. Нас не интересует, чем являются состояния и буквы алфавита, мы лишь требуем от этих множеств следующее:
		\begin{itemize}
			\item множество должно быть конечным;
			\item должна быть возможность итерироваться (пробегаться) по этому множеству;
			\item должна быть возможность работать с подмножествами этих множеств.
		\end{itemize}
		Значит, множества можно закодировать одним числом - его мощностью $n$. При этом, если нужно выделить отдельный элемент, то это тоже будет число $i$ - индекс элемента такой, что $ i \in Z_{n}$. Подмножества конечного множества мощностью $n$ будет закодирован характеристическим вектором длинной $n$.
		
		Характеристический вектор реализован в виде класса ax::bitvector, который занимает на один бит иформации ровно один бит памяти (то есть вектор занимает $\lceil n/8 \rceil$ байт памяти).
		
		Функцию переходов будем называть таблицей переходов, так как теперь мы работаем не с буквами и состояниями, а с соответствующими индексами. Таблица реализована в виде класса ax::matrix.
		\subsection{Реализация алгоритма удаления $\lambda$-переходов}
		\subsection{Реализация алгоритма детерминизации КНА}
		\subsection{Уязвимые для критики места}
	\section{Тестирование}
		Все тесты находятся в дирректории tests и выполняются с помощью фреймворка catch.
		Запуск всех тестов сразу : $make \ \ test\_all$.
		\subsection{Unit-тестирование}
		Тестирование можно запустить отдельно для каждого класса:
		\begin{itemize}
			\item Тестирование собственных вспомогательных библиотек:
				\begin{itemize}
					\item ax::bitvector - $make\ \ \_bitvector\_test$;
					\item ax::matrix - $make\ \ \_matrix\_test$;
				\end{itemize}
				Для запуска всех тестов библиотеки сразу -  $make \_ax\_libs\_test$
			
			\item Тестирование автоматов:
				\begin{itemize}
					\item machines::base\_finite\_state\_machine - $make\ \ \_base\_fsm\_test$;
					\item machines::finite\_state\_machine - $make\ \ \_finite\_state\_machine\_test$;
					\item machines::deterministic\_finite\_state\_machine - $make\ \ \_deterministic$;
				\end{itemize}
				Для запуска всех тестов на автоматы сразу -  $make \_machines\_test$
			
			\item Тестирование алгоритмов:
				\begin{itemize}
					\item Удаление $\lambda$-переходов - $make\ \ \_lambda\_transition\_deletion$;
					\item Детерминирование КНА - $make\ \ \_determinization$;
				\end{itemize}
				Для запуска всех тестов на алгоритмы сразу -  $make \_algorithms\_test$
			
		\end{itemize}
		\subsection{Умное тестирование}
		Умное тестирование основывается на следствии теоремы Клини - автомат реализует распознаватель некоторого регулярного выражения. Всего производятся три теста, каждый из которых берет регулярное выражение и соответствующий файл.fsa - файл описания автомата (см. 0.6.1), и затем огромное число раз генерирует последовательность чисел необходимого алфавита и сравнивает ответы регулярного выражения и детерминизированного автомата.
		
		Запуск такого теста: $make\ \ smart\_test$.
		 
	\section{Использование алгоритма}
		\subsection{Формат файла-автомата (.fsa)}
		
		\subsection{Компиляция и запуск основной программы}
	\section{Заключение}
		\sout{Реализовано все круто, добавить нечего, почаще бы так писали код.} 
		
	
	\begin{thebibliography}{0}
		\bibitem{Discra}
			А.\,И.\,Белоусов, С.\,Б.\,Ткачев. Дискретная математика.\\
			 Издательство МГТУ им. Н.\,Э.\,Баумана, Москвв, 2002.

	\end{thebibliography}
	
\end{document}
\grid
\grid
