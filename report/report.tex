\documentclass[12pt]{report}
\usepackage{ucs}
\usepackage[cp1251]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath}
\usepackage{ulem}           
\usepackage[noend]{algorithmic}                            
\usepackage{lipsum}% Мало ли пригодится рыба
\usepackage{titletoc}% http://ctan.org/pkg/titletoc


\renewcommand*\contentsname{Оглавление}
\titlecontents*{chapter}% <section-type>
  [0pt]% <left>
  {}% <above-code>
  {\bfseries\chaptername\ \thecontentslabel\quad}% <numbered-entry-format>
  {}% <numberless-entry-format>
  {\bfseries\hfill\contentspage}% <filler-page-format>


\title{Детерминизация конечного автомата}

\date{}
\author{Кузнецов А.Д.}

\begin{document}
	\maketitle	
	\pagenumbering{arabic}
	\tableofcontents

	\section{Краткая теоретическая часть}
		Ниже приводятся определения и утверждения, которые будут использованы для дальнейших пояснений к реализации алгоритма детерминизации.
		\subsection{Автомат}
		Конечный недетерминированный автомат (КНА) $M$ --- это кортеж вида
		\[
			M = ( A, Q, q_0, F, \delta),	
		\]
		где	
		\begin{itemize}
			\item $A =  \{a_0, a_1, \dots, a_{m-1}\}$ --- входной алфавит, т.е. множество символов, причем конечное : $ |A| = m $;
			\item $Q =  \{q_0, q_1, \dots, q_{n-1}\}$ --- множество состояний автомата,\\ тоже конечное: $|Q|=n$;
			\item $q_0$ --- начальное состояние автомата, то есть $q_0 \in Q$;
			\item $F \subset Q$ --- выходные состояния автомата; 
			\item $\delta: Q\times A\rightarrow 2^Q$ --- функция переходов автомата.
		\end{itemize}
		Если в автомате разрешены переходы по пустому символу, то входной алфавит дополняется фиктивным символом $\lambda$ (в иностранной литературе его чаще обозначают $\varepsilon$). В таком случае автомат называют $\lambda$-КНА ($\varepsilon$-FSA). Входной алфавит при этом будем обозначать так же, то есть если речь идет о $\lambda$-КНА, то подразумевается, что $A~\leftarrow~A~\bigcup~\{\lambda\}$, а мощность $|A|=m + 1$.
		
		Конечный детерминированный автомат (КДА) $M$ --- это такой КНА, где функция переходов $\delta$ выглядит так:
		\[
			\delta: Q\times A\rightarrow 2^Q,	
		\]
		т.е. из любого состояния по любой букве возможен переход в точности в одно состояние - это и обеспечивает детерминированность работы такого автомата.
		\subsection{Теорема Клини}
		Пусть $A=\{a_0,...,a_{n-1}\}$ - произвольный алфавит. Язык $L\subseteq A^*$ является элементом полукольца регулярных языков $R(A)$ в алфавите $A$ тогда и только тогда, когда он допускается некоторым конечным автоматом.
		



	\section{Постановка задачи}
	Теперь сформулируем задачу в вышеуказанных терминах:
	\begin{center}
  		Реализовать алгоритм преобразования $\lambda$-КНА $M$ в КНА $\hat M$ так, чтобы распознаваемые ими языки совпадали, т.е. $L(M)=L(\hat M)$.
	\end{center}
	
	\section{Алгоритм детерминизации автомата}
		Алгоритм детерминизации осуществляется в два шага - удаление $\lambda$-переходов (то есть переход от $\lambda$-КНА к КНА) и непосредственно детерминизация КНА (КНА $\rightarrow$ КДА).
		\subsection{Удаление $\lambda$-переходов}
		Для любого $\lambda$-КНА можно построить эквивалентный ему КНА (Здесь и далее под эквивалентностью автоматов подразумевается совпадение распознаваемых ими языков). Доказательство этого утверждения входит в обоснование алгоритма детерминизации, который описан в учебникех~\cite{Discra}. 
		Основная идея этого шага такая - из состояния $q_i$ существует переход по букве $a$ в состояние $q_j$ тогда и только тогда, когда выполняется одно из двух условий:
		\begin{itemize}
			\item $q_j \in \delta(q_i, a)$;
			\item $\exists (q_{1}, q_{2},\dots, q_{p}) \in \bigcup \limits_{p=1}^{n}Q^p : \\ (q_1 \in \delta(q_i, \lambda))\wedge (\forall k = \overline{1,p-1})(q_k \in \delta(q_{k+1}, \lambda))\wedge(q_p in \delta(q_i, a)) $.
		\end{itemize}
		То есть, если из состояния $q_i$ какая-то цепь пустых переходов ведет в состояние, из которого есть переход в $q_i$ по букве $a$, то в новом КНА будет переход из $q_i$ в $q_i$ по букве $a$.
		\subsection{Детерминизация КНА}
		Теперь у нас есть КНА, который всегда можно детерминизировать (это утверждение тоже есть и доказано в учебнике).
		
		Алгоритм интуитивно следует понимать так: если моделировать КНА на компьютере, то прежде всего придется реализовать автомат так, чтобы он мог находиться одновременно в различных состояниях, в которые он может попасть по прочитанному подслову входной последовательности. Точно так же и тут - пусть в КДА состояния будут в биективном отношении с совокупностью подмножеств состояний входного КДА. Такие состояния результирующего КДА будем называть гиперсостоянием (исключительно ради удобства, в коде, реализующем алгоритм, они так и называются). Помимо этого, будем говорить, что состояние входит в гиперсостояние. если это состояние входит в то подмножество $Q$, в котором гиперсостояние находится в биективном отношении.
		
		Теперь вполне разумна мысль. что переход из одного гиперсостояния в другое по букве возможен тогда, когда хотя бы из одного состояния в первом гиперсостоянии есть переход по этой букве в состояния из второго гиперсостояния. Вообще и обратное следствие верно, но доказывать его сложнее.
		
		Так как уже невозможно это произносить, читать и, поверьте мне, печатать, перейдем непосредственно к алгоритму.
		\newpage
		
		\def\algorithmicrequire{\textbf{Вход:}}
		\def\algorithmicensure{\textbf{Выход:}}
		\def\algorithmicif{\textbf{если}}
		\def\algorithmicthen{\textbf{то}}
		\def\algorithmicelse{\textbf{иначе}}
		\def\algorithmicelsif{\textbf{иначе если}}
		\def\algorithmicfor{\textbf{для}}
		\def\algorithmicforall{\textbf{для всех}}
		\def\algorithmicdo{}
		\def\algorithmicwhile{\textbf{пока}}
		\def\algorithmicrepeat{\textbf{повторять}}
		\def\algorithmicuntil{\textbf{пока}}
		\def\algorithmicloop{\textbf{цикл}}
		% переопределение стиля комментариев
		\def\algorithmiccomment#1{\quad// {\sl #1}}
		
		
		\begin{algorithmic}[1]
			\REQUIRE $M = ( A, Q, q_0, F, \delta)$;
			\ENSURE $\hat M = (\hat A, S, s_0, F_s, \hat\delta)$;
			\STATE $\hat A := A$; \COMMENT{Алфавиты совпадают}
			\STATE $ s_0 := \{q_0\}$ \COMMENT{Входное гиперсостояние соответсвует входному состоянию исходного автомата}
			\STATE $ F_s = \O $ \COMMENT{Множество выходных гиперсостояний}
			\STATE $ DET = \O $ \COMMENT{Множество уже детерминизированных гиперсостояний}
			\STATE $ NONDET =  \{s_0\}$ \COMMENT{Множество еще недетерминизированных гиперсостояний}
			
			\WHILE{$NONDET \neq \O$} 				
				\STATE $ state := choice(NONDET)$; \COMMENT{Выбираем како-либо элемент из множества и извлекаем его}
				\FORALL{$a \in A$}
					\STATE $ next := \O$; \COMMENT{Новое гиперсостояние при переходе по букве $a$}
					\FORALL{$q \in state$}
						\STATE $ next := next\ \cup\ \delta(q,a) $; 
					\ENDFOR
					\STATE $\hat\delta(state, a) := next $;\COMMENT{Добавляем соответствующий переход по букве}
					\IF{$next \notin DET$}
						\STATE $ NONDET := NONDET \ \cup\ \{next\}$; \COMMENT{Если гиперсостояние не было детерминированно, то добавляем его в множество ожидающих детерминизацию}
					\ENDIF
					\IF{$state \cap F \neq \O$}
						\STATE $ F_s := F_s \ \cup\ \{state\}$; \COMMENT{Если хотя бы одно состояние гиперсостояния было выходным, то все гиперсостояние - выходное}
					\ENDIF
				\ENDFOR
			\ENDWHILE
			\STATE $ S := DET $ ;
			\STATE $ \hat M = (\hat A, S, s_0, F_s, \hat\delta)$ ; \COMMENT{Возвращаем детерминированный автомат}
			
		\end{algorithmic}
	
		\subsection{Оценка сложности алгоритма}
		Очевидно, самая сложная часть этого алгоритма - детерминизация КНА. Количество гиперсостояний органиченно сверху числом $2^n$, так как различных гиперсостояний ровно столько, сколько различных подмножеств $n$-элементного множетсва состояний $Q$. То есть в худшем случае предстоит детерминизировать $O(2^n)$ гиперсостояний.
		
		 При каждой детерминизации гиперсостояния алгоритм проверяет по всем буквам (8 строка алгоритма) и по всем состояниям, которые оно в себе содержит, переходы, а затем объекдиняет их с уже выявленными для предыдущих букв, то есть сложность такого шага $O(m)O(n)O(n) = O(mn^2)$ (это явно сложнее чем еще одно пересечение (15 строка) и объединение (16 строка), так что это и будет сложность шага.
		 
		 Итого $O(2^n)$ шагов сложностью $O(mn^2)$, итого  $O(mn^22^n)$.
		 
	\section{Реализация алгоритма детерминизации автомата}
		\subsection{Кодирование автоматов (реализация классов)}
		\subsection{Реализация алгоритма удаления $\lambda$-переходов}
		\subsection{Реализация алгоритма детерминизации КНА}
		\subsection{Уязвимые для критики места}
	\section{Тестирование}
		\subsection{Unit-тестирование}
		\subsection{Умное тестирование}
	\section{Использование алгоритма}
		\subsection{Формат файла-автомата (.fsa)}
		\subsection{Компиляция и запуск основной программы}
	\section{Заключение}
		\sout{Реализовано все круто, добавить нечего, почаще бы так писали код.} 
		
	
	\begin{thebibliography}{0}
		\bibitem{Discra}
			А.\,И.\,Белоусов, С.\,Б.\,Ткачев. Дискретная математика.\\
			 Издательство МГТУ им. Н.\,Э.\,Баумана, Москвв, 2002.

	\end{thebibliography}
	
\end{document}
